---
- name: Migrate SMS Bridge to Production_2 Schema
  hosts: localhost
  become: no
  connection: local
  
  collections:
    - community.docker

  vars_files:
    - ../vault.yml

  vars:
    pg_user: "postgres"
    pg_db: "sms_bridge"
    project_dir: "{{ ansible_env.HOME }}/sms_bridge"
    backup_dir: "{{ project_dir }}/backups"
    backup_timestamp: "{{ ansible_date_time.iso8601_basic_short }}"

  tasks:
    - name: Display migration start message
      debug:
        msg: |
          ========================================
          SMS Bridge Production_2 Migration
          ========================================
          This playbook will:
          1. Create database backup
          2. Stop all SMS Bridge containers gracefully
          3. Apply Production_2 schema migration
          4. Rebuild and restart containers
          5. Verify deployment
          ========================================

    # ===================================
    # Phase 1: Pre-Migration Backup
    # ===================================
    
    - name: Create backup directory
      file:
        path: "{{ backup_dir }}"
        state: directory
        mode: '0755'

    - name: Check if PostgreSQL container is running
      community.docker.docker_container_info:
        name: postgres
      register: postgres_status
      ignore_errors: yes

    - name: Create PostgreSQL backup (if container is running)
      shell: |
        docker exec postgres pg_dump -U {{ pg_user }} {{ pg_db }} > {{ backup_dir }}/sms_bridge_backup_{{ backup_timestamp }}.sql
      when: postgres_status.exists and postgres_status.container.State.Status == "running"
      ignore_errors: yes

    - name: Backup Redis data (if container is running)
      shell: |
        docker exec redis redis-cli -a {{ redis_password }} --rdb {{ backup_dir }}/redis_backup_{{ backup_timestamp }}.rdb SAVE
      when: postgres_status.exists
      ignore_errors: yes

    - name: Create backup of current schema
      copy:
        src: ../schema.sql
        dest: "{{ backup_dir }}/schema_old_{{ backup_timestamp }}.sql"
      ignore_errors: yes

    - name: Display backup status
      debug:
        msg: "Backups created in {{ backup_dir }} with timestamp {{ backup_timestamp }}"

    # ===================================
    # Phase 2: Graceful Container Shutdown
    # ===================================

    - name: Stop SMS Receiver container (graceful shutdown)
      shell: docker stop sms_receiver 2>/dev/null || true
      ignore_errors: yes

    - name: Wait for SMS Receiver to stop
      pause:
        seconds: 5

    - name: Stop monitoring containers
      shell: docker stop {{ item }} 2>/dev/null || true
      loop:
        - grafana
        - prometheus
        - redis_exporter
        - postgres_exporter
      ignore_errors: yes

    - name: Stop PgBouncer (connection pooler)
      shell: docker stop pgbouncer 2>/dev/null || true
      ignore_errors: yes

    - name: Wait for active connections to drain
      pause:
        seconds: 5

    - name: Stop Redis container
      shell: docker stop redis 2>/dev/null || true
      ignore_errors: yes

    - name: Stop PostgreSQL container
      shell: docker stop postgres 2>/dev/null || true
      ignore_errors: yes

    - name: Verify all containers are stopped
      shell: docker ps --filter "network=sms_bridge_network" --format "{{"{{.Names}}"}}"
      register: running_containers

    - name: Display stopped containers
      debug:
        msg: "Remaining running containers: {{ running_containers.stdout_lines | default('None - all stopped') }}"

    # ===================================
    # Phase 3: Schema Migration
    # ===================================

    - name: Copy Production_2 schema to project directory
      copy:
        src: ../schema.sql
        dest: "{{ project_dir }}/schema_production_2.sql"

    - name: Create migration SQL script
      copy:
        dest: "{{ project_dir }}/migration_production_2.sql"
        content: |
          -- Production_2 Schema Migration Script
          -- This script safely migrates from old schema to Production_2
          
          BEGIN;
          
          -- Step 1: Backup existing data (if needed for rollback)
          -- Tables we're keeping: blacklist_sms, onboarding_mobile
          
          -- Step 2: Create new Production_2 tables
          
          -- Create input_sms with new structure (merged from input_sms + sms_monitor)
          CREATE TABLE IF NOT EXISTS input_sms_new (
              id SERIAL PRIMARY KEY,
              redis_id INTEGER NOT NULL,
              mobile_number VARCHAR(15) NOT NULL,
              country_code VARCHAR(5),
              local_mobile VARCHAR(15),
              sms_message TEXT NOT NULL,
              received_timestamp TIMESTAMPTZ NOT NULL,
              device_id VARCHAR(100),
              mobile_check INTEGER DEFAULT 3,
              duplicate_check INTEGER DEFAULT 3,
              header_hash_check INTEGER DEFAULT 3,
              count_check INTEGER DEFAULT 3,
              foreign_number_check INTEGER DEFAULT 3,
              blacklist_check INTEGER DEFAULT 3,
              time_window_check INTEGER DEFAULT 3,
              validation_status VARCHAR(20) DEFAULT 'pending',
              failed_at_check VARCHAR(30),
              created_at TIMESTAMPTZ DEFAULT NOW()
          );
          
          -- Migrate existing input_sms data to new structure
          INSERT INTO input_sms_new (
              mobile_number, sms_message, received_timestamp, 
              country_code, local_mobile, redis_id, created_at
          )
          SELECT 
              sender_number, sms_message, received_timestamp,
              country_code, local_mobile, 
              ROW_NUMBER() OVER (ORDER BY created_at) as redis_id,
              created_at
          FROM input_sms
          ON CONFLICT DO NOTHING;
          
          -- Drop old input_sms and rename new one
          DROP TABLE IF EXISTS input_sms CASCADE;
          ALTER TABLE input_sms_new RENAME TO input_sms;
          
          -- Create indexes
          CREATE INDEX IF NOT EXISTS idx_input_redis_id ON input_sms (redis_id);
          CREATE INDEX IF NOT EXISTS idx_input_mobile ON input_sms (mobile_number);
          CREATE INDEX IF NOT EXISTS idx_input_validation_status ON input_sms (validation_status);
          CREATE INDEX IF NOT EXISTS idx_input_received_timestamp ON input_sms (received_timestamp);
          CREATE INDEX IF NOT EXISTS idx_input_country_local ON input_sms (country_code, local_mobile);
          
          -- Update onboarding_mobile table structure
          ALTER TABLE onboarding_mobile ADD COLUMN IF NOT EXISTS email VARCHAR(100);
          ALTER TABLE onboarding_mobile ADD COLUMN IF NOT EXISTS device_id VARCHAR(100);
          ALTER TABLE onboarding_mobile ADD COLUMN IF NOT EXISTS user_deadline TIMESTAMPTZ;
          ALTER TABLE onboarding_mobile ADD COLUMN IF NOT EXISTS expires_at TIMESTAMPTZ;
          ALTER TABLE onboarding_mobile ADD COLUMN IF NOT EXISTS is_validated BOOLEAN DEFAULT FALSE;
          ALTER TABLE onboarding_mobile ADD COLUMN IF NOT EXISTS validated_at TIMESTAMPTZ;
          
          -- Update indexes for onboarding_mobile
          CREATE INDEX IF NOT EXISTS idx_onboard_mobile ON onboarding_mobile (mobile_number);
          CREATE INDEX IF NOT EXISTS idx_onboard_hash ON onboarding_mobile (hash);
          CREATE INDEX IF NOT EXISTS idx_onboard_request_timestamp ON onboarding_mobile (request_timestamp);
          CREATE INDEX IF NOT EXISTS idx_onboard_device ON onboarding_mobile (device_id);
          
          -- Update blacklist_sms table structure
          ALTER TABLE blacklist_sms ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW();
          
          -- Create indexes for blacklist_sms
          CREATE INDEX IF NOT EXISTS idx_blacklist_country_local ON blacklist_sms (country_code, local_mobile);
          CREATE INDEX IF NOT EXISTS idx_blacklist_blacklisted_at ON blacklist_sms (blacklisted_at);
          
          -- Create power_down_store table
          CREATE TABLE IF NOT EXISTS power_down_store (
              id SERIAL PRIMARY KEY,
              mobile_number VARCHAR(15) NOT NULL,
              sms_message TEXT NOT NULL,
              received_timestamp TIMESTAMPTZ NOT NULL,
              device_id VARCHAR(100),
              stored_at TIMESTAMPTZ DEFAULT NOW(),
              processed BOOLEAN DEFAULT FALSE,
              processed_at TIMESTAMPTZ
          );
          
          CREATE INDEX IF NOT EXISTS idx_powerdown_processed ON power_down_store (processed);
          CREATE INDEX IF NOT EXISTS idx_powerdown_stored_at ON power_down_store (stored_at);
          
          -- Create power_down_store_counters table
          CREATE TABLE IF NOT EXISTS power_down_store_counters (
              counter_name VARCHAR(50) PRIMARY KEY,
              counter_value BIGINT NOT NULL DEFAULT 0,
              updated_at TIMESTAMPTZ DEFAULT NOW()
          );
          
          INSERT INTO power_down_store_counters (counter_name, counter_value) 
          VALUES 
              ('queue_input_sms', 0),
              ('queue_onboarding', 0)
          ON CONFLICT (counter_name) DO NOTHING;
          
          -- Create sms_settings table
          CREATE TABLE IF NOT EXISTS sms_settings (
              setting_key VARCHAR(100) PRIMARY KEY,
              setting_value TEXT NOT NULL,
              setting_type VARCHAR(20) DEFAULT 'string',
              category VARCHAR(50) DEFAULT 'general',
              description TEXT,
              updated_at TIMESTAMPTZ DEFAULT NOW()
          );
          
          -- Insert default settings for Production_2
          INSERT INTO sms_settings (setting_key, setting_value, setting_type, category, description) 
          VALUES 
              ('onboarding_ttl_seconds', '86400', 'integer', 'general', 'Redis TTL for onboarding entries (24 hours)'),
              ('user_timelimit_seconds', '300', 'integer', 'general', 'User deadline for SMS submission (5 minutes)'),
              ('hash_salt_length', '16', 'integer', 'general', 'Salt length for hash generation'),
              ('hetzner_sync_interval_seconds', '10', 'integer', 'sync', 'Hetzner Supabase sync frequency (validated only)'),
              ('local_sync_interval_seconds', '120', 'integer', 'sync', 'Local PostgreSQL dump frequency (all data)'),
              ('blacklist_check_interval_seconds', '300', 'integer', 'sync', 'Blacklist reload from PostgreSQL frequency'),
              ('mobile_check_enabled', 'true', 'boolean', 'validation', 'Enable mobile format validation'),
              ('duplicate_check_enabled', 'true', 'boolean', 'validation', 'Enable duplicate detection'),
              ('header_hash_check_enabled', 'true', 'boolean', 'validation', 'Enable header and hash validation'),
              ('count_check_enabled', 'true', 'boolean', 'validation', 'Enable SMS count threshold check'),
              ('foreign_number_check_enabled', 'true', 'boolean', 'validation', 'Enable foreign country code check'),
              ('blacklist_check_enabled', 'true', 'boolean', 'validation', 'Enable blacklist check'),
              ('time_window_check_enabled', 'true', 'boolean', 'validation', 'Enable time window validation'),
              ('count_check_threshold', '5', 'integer', 'thresholds', 'Max SMS per mobile in 24h before rejection'),
              ('blacklist_threshold', '10', 'integer', 'thresholds', 'Count to trigger permanent blacklist'),
              ('allowed_country_codes', '["91", "1", "44", "61", "33", "49"]', 'json', 'validation', 'Allowed country codes for foreign number check'),
              ('redis_host', 'localhost', 'string', 'infrastructure', 'Redis server host'),
              ('redis_port', '6379', 'integer', 'infrastructure', 'Redis server port'),
              ('pgbouncer_pool_size', '10', 'integer', 'infrastructure', 'PgBouncer connection pool size'),
              ('log_level', 'INFO', 'string', 'monitoring', 'Application log level (DEBUG, INFO, WARNING, ERROR)'),
              ('maintenance_mode', 'false', 'boolean', 'monitoring', 'Enable maintenance mode (reject new requests)')
          ON CONFLICT (setting_key) DO NOTHING;
          
          -- Step 3: Drop obsolete tables (commented for safety - uncomment if confirmed)
          -- DROP TABLE IF EXISTS out_sms CASCADE;
          -- DROP TABLE IF EXISTS sms_monitor CASCADE;
          -- DROP TABLE IF EXISTS count_sms CASCADE;
          -- DROP TABLE IF EXISTS system_settings CASCADE;
          
          -- Step 4: Verify migration
          SELECT 'Migration completed successfully' as status;
          
          COMMIT;

    - name: Display migration script created
      debug:
        msg: "Migration script created at {{ project_dir }}/migration_production_2.sql"

    # ===================================
    # Phase 4: Start PostgreSQL and Apply Migration
    # ===================================

    - name: Create Docker network if it doesn't exist
      community.docker.docker_network:
        name: sms_bridge_network
        state: present
      ignore_errors: yes

    - name: Start PostgreSQL container for migration
      community.docker.docker_container:
        name: postgres
        image: postgres:15
        state: started
        restart_policy: unless-stopped
        networks:
          - name: sms_bridge_network
            aliases:
              - postgres
        ports:
          - "5432:5432"
        volumes:
          - pg_data:/var/lib/postgresql/data
          - "{{ project_dir }}/migration_production_2.sql:/migration.sql:ro"
        env:
          POSTGRES_PASSWORD: "{{ pg_password }}"
          POSTGRES_DB: "{{ pg_db }}"

    - name: Wait for PostgreSQL container to initialize
      pause:
        seconds: 10

    - name: Wait for PostgreSQL to be ready
      shell: |
        for i in {1..60}; do
          if docker exec postgres pg_isready -U {{ pg_user }} -h localhost 2>/dev/null; then
            echo "PostgreSQL is ready"
            exit 0
          fi
          echo "Waiting for PostgreSQL... attempt $i/60"
          sleep 3
        done
        exit 1
      register: pg_ready
      retries: 1
      delay: 0

    - name: Apply Production_2 schema migration
      shell: |
        docker exec postgres psql -U {{ pg_user }} -d {{ pg_db }} -f /migration.sql
      register: migration_result

    - name: Display migration result
      debug:
        var: migration_result.stdout_lines

    - name: Verify new tables exist
      shell: |
        docker exec postgres psql -U {{ pg_user }} -d {{ pg_db }} -c "\dt"
      register: tables_list

    - name: Display database tables
      debug:
        var: tables_list.stdout_lines

    - name: Verify sms_settings table content
      shell: |
        docker exec postgres psql -U {{ pg_user }} -d {{ pg_db }} -c "SELECT setting_key, category, setting_type FROM sms_settings ORDER BY category, setting_key;"
      register: settings_list

    - name: Display sms_settings
      debug:
        var: settings_list.stdout_lines

    # ===================================
    # Phase 5: Update Application Code
    # ===================================

    - name: Copy updated core application package
      copy:
        src: ../core/
        dest: "{{ project_dir }}/core/"

    - name: Copy updated templates
      copy:
        src: ../core/templates/
        dest: "{{ project_dir }}/core/templates/"

    - name: Copy updated static files
      copy:
        src: ../core/static/
        dest: "{{ project_dir }}/core/static/"

    # ===================================
    # Phase 6: Restart All Containers
    # ===================================

    - name: Start Redis container
      community.docker.docker_container:
        name: redis
        image: redis:7-alpine
        state: started
        restart_policy: unless-stopped
        networks:
          - name: sms_bridge_network
            aliases:
              - redis
        ports:
          - "6379:6379"
        command: ["redis-server", "--maxmemory", "256mb", "--maxclients", "1000", "--requirepass", "{{ redis_password }}"]

    - name: Wait for Redis to start
      pause:
        seconds: 3

    - name: Start PgBouncer container
      community.docker.docker_container:
        name: pgbouncer
        image: brainsam/pgbouncer
        state: started
        restart_policy: unless-stopped
        networks:
          - name: sms_bridge_network
            aliases:
              - pgbouncer
        ports:
          - "6432:6432"
        env:
          DB_HOST: postgres
          DB_PORT: 5432
          DB_USER: "{{ pg_user }}"
          DB_PASSWORD: "{{ pg_password }}"
          DB_NAME: "{{ pg_db }}"
          POOL_MODE: transaction
          MAX_CLIENT_CONN: 1000
          DEFAULT_POOL_SIZE: 10

    - name: Rebuild SMS receiver Docker image with Production_2 code
      community.docker.docker_image:
        name: sms_receiver_image
        build:
          path: "{{ project_dir }}"
          dockerfile: Dockerfile
        source: build
        state: present
        force_source: yes

    - name: Start SMS receiver container with Production_2
      community.docker.docker_container:
        name: sms_receiver
        image: sms_receiver_image
        state: started
        restart_policy: unless-stopped
        networks:
          - name: sms_bridge_network
            aliases:
              - sms_receiver
        ports:
          - "8080:8080"
        volumes:
          - "{{ project_dir }}/logs:/app/logs:rw"
        env:
          CF_API_KEY: "{{ cf_api_key }}"
          CF_BACKEND_URL: "{{ cf_backend_url }}"
          POSTGRES_HOST: pgbouncer
          POSTGRES_DB: "{{ pg_db }}"
          POSTGRES_USER: "{{ pg_user }}"
          POSTGRES_PASSWORD: "{{ pg_password }}"
          POSTGRES_PORT: "6432"
          REDIS_HOST: redis
          REDIS_PORT: 6379
          REDIS_PASSWORD: "{{ redis_password }}"
          HASH_SECRET_KEY: "{{ hash_secret_key }}"
          LOG_LEVEL: INFO
          LOG_DIR: /app/logs

    - name: Start Prometheus container
      community.docker.docker_container:
        name: prometheus
        image: prom/prometheus:latest
        state: started
        restart_policy: unless-stopped
        networks:
          - name: sms_bridge_network
            aliases:
              - prometheus
        ports:
          - "9090:9090"
        volumes:
          - "{{ project_dir }}/prometheus.yml:/etc/prometheus/prometheus.yml:ro"

    - name: Start Grafana container
      community.docker.docker_container:
        name: grafana
        image: grafana/grafana:latest
        state: started
        restart_policy: unless-stopped
        networks:
          - name: sms_bridge_network
            aliases:
              - grafana
        ports:
          - "3001:3000"
        volumes:
          - "{{ project_dir }}/grafana/provisioning:/etc/grafana/provisioning:ro"
        env:
          GF_SECURITY_ADMIN_PASSWORD: "{{ grafana_admin_password }}"

    - name: Start PostgreSQL exporter container
      community.docker.docker_container:
        name: postgres_exporter
        image: prometheuscommunity/postgres-exporter
        state: started
        restart_policy: unless-stopped
        networks:
          - name: sms_bridge_network
            aliases:
              - postgres_exporter
        ports:
          - "9187:9187"
        env:
          DATA_SOURCE_NAME: "postgresql://{{ pg_user }}:{{ pg_password }}@postgres:5432/{{ pg_db }}?sslmode=disable"

    - name: Start Redis exporter container
      community.docker.docker_container:
        name: redis_exporter
        image: oliver006/redis_exporter
        state: started
        restart_policy: unless-stopped
        networks:
          - name: sms_bridge_network
            aliases:
              - redis_exporter
        ports:
          - "9121:9121"
        command: ["-redis.addr=redis://:{{ redis_password }}@redis:6379"]

    # ===================================
    # Phase 7: Verify Deployment
    # ===================================

    - name: Wait for all containers to stabilize
      pause:
        seconds: 10

    - name: Check container status
      shell: docker ps --filter "network=sms_bridge_network" --format "table {{"{{.Names}}"}}\t{{"{{.Status}}"}}\t{{"{{.Ports}}"}}"
      register: containers_status

    - name: Display container status
      debug:
        var: containers_status.stdout_lines

    - name: Check SMS receiver health endpoint
      uri:
        url: http://localhost:8080/health
        method: GET
        status_code: 200
      register: health_check
      retries: 5
      delay: 3
      ignore_errors: yes

    - name: Display health check result
      debug:
        var: health_check.json
      when: health_check is succeeded

    - name: Check admin UI endpoint
      uri:
        url: http://localhost:8080/admin/settings/ui
        method: GET
        status_code: 200
      register: admin_ui_check
      retries: 3
      delay: 2
      ignore_errors: yes

    - name: Test Redis connectivity
      shell: |
        docker exec redis redis-cli -a {{ redis_password }} PING
      register: redis_ping

    - name: Display Redis status
      debug:
        msg: "Redis status: {{ redis_ping.stdout }}"

    - name: Check SMS receiver logs for errors
      shell: docker logs sms_receiver --tail 50
      register: receiver_logs

    - name: Display recent SMS receiver logs
      debug:
        var: receiver_logs.stdout_lines

    # ===================================
    # Final Summary
    # ===================================

    - name: Display migration summary
      debug:
        msg: |
          ========================================
          Production_2 Migration Complete!
          ========================================
          
          ✅ Database backup: {{ backup_dir }}/sms_bridge_backup_{{ backup_timestamp }}.sql
          ✅ Schema migrated to Production_2
          ✅ All containers restarted
          
          Services:
          - SMS Bridge API: http://localhost:8080
          - Admin UI: http://localhost:8080/admin/settings/ui
          - Health Check: http://localhost:8080/health
          - Grafana: http://localhost:3001
          - Prometheus: http://localhost:9090
          
          New Features:
          - Redis-first architecture (6 PostgreSQL tables)
          - Dual time windows (user_deadline + expires_at)
          - Admin UI for settings management
          - Dynamic configuration (no restarts needed)
          - Count check validation (Redis counters)
          - Production_2 POST /onboard/register endpoint
          
          Next Steps:
          1. Verify health check: curl http://localhost:8080/health
          2. Access admin UI: http://localhost:8080/admin/settings/ui
          3. Test POST endpoint with new fields (mobile, email, device_id)
          4. Monitor logs: docker logs sms_receiver -f
          
          Rollback (if needed):
          - Restore database: docker exec -i postgres psql -U postgres sms_bridge < {{ backup_dir }}/sms_bridge_backup_{{ backup_timestamp }}.sql
          - Redeploy old version: ansible-playbook setup_sms_bridge.yml
          ========================================

    - name: Create migration report file
      copy:
        dest: "{{ project_dir }}/migration_report_{{ backup_timestamp }}.txt"
        content: |
          SMS Bridge Production_2 Migration Report
          ==========================================
          
          Timestamp: {{ ansible_date_time.iso8601 }}
          
          Backup Location: {{ backup_dir }}
          - Database backup: sms_bridge_backup_{{ backup_timestamp }}.sql
          - Schema backup: schema_old_{{ backup_timestamp }}.sql
          
          Migration Status: {{ migration_result.rc == 0 | ternary('SUCCESS', 'FAILED') }}
          
          Container Status:
          {{ containers_status.stdout }}
          
          Health Check: {{ health_check is succeeded | ternary('PASSED', 'FAILED') }}
          Admin UI: {{ admin_ui_check is succeeded | ternary('ACCESSIBLE', 'NOT ACCESSIBLE') }}
          
          Production_2 Features Deployed:
          - Redis-first architecture
          - 6 PostgreSQL tables (input_sms, onboarding_mobile, blacklist_sms, power_down_store, power_down_store_counters, sms_settings)
          - Dual time windows (X=5min, TTL=24h)
          - Admin UI for settings management
          - POST /onboard/register endpoint
          - Count check validation
          - Dynamic configuration system
          
          ==========================================

    - name: Display migration report location
      debug:
        msg: "Migration report saved to: {{ project_dir }}/migration_report_{{ backup_timestamp }}.txt"
